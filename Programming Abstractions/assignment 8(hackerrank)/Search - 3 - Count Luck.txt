#include <bits/stdc++.h>

using namespace std;

vector<string> split_string(string);

bool crossroad(vector<string> &matrix, int i, int j){
    int way = 0;
    if (i != matrix.size() - 1 && matrix[i + 1][j] != 'X') way++;
    if (i != 0 && matrix[i - 1][j] != 'X') way++;
    if (j != matrix[i].size()-1 && matrix[i][j+1] != 'X') way++;
    if (j != 0 && matrix[i][j-1] != 'X') way++;
    if(way>1) return true;
    return false;
}

int countWaves(vector<string> &matrix, int i, int j, int k) {
  if (matrix[i][j] == '*') return k;
  int t;
  if(crossroad(matrix,i,j)) k++;
  if (i != matrix.size() - 1 && matrix[i + 1][j] != 'X') {
        if (matrix[i + 1][j] != '*') matrix[i + 1][j] = 'X';
        t = countWaves(matrix, i + 1, j, k);
        matrix[i + 1][j] = '.';
        if (t != -1) return t;   
    } 
    if( i != 0 && matrix[i-1][j] != 'X'){
        if (matrix[i-1][j] != '*') matrix[i - 1][j] = 'X';
        t = countWaves(matrix, i - 1, j, k);
        matrix[i - 1][j] = '.';
        if (t != -1) return t; 
    }
    if (j != matrix[i].size()-1 && matrix[i][j+1] != 'X') {
        if(matrix[i][j + 1] != '*') matrix[i][j + 1] = 'X';
        t = countWaves(matrix, i, j + 1, k);
        matrix[i][j + 1] = '.';
        if (t != -1) return t;
    }
    if (j != 0 && matrix[i][j-1] != 'X') {
        if(matrix[i][j-1] != '*') matrix[i][j-1] = 'X';
        t = countWaves(matrix, i, j - 1, k);
        matrix[i][j-1] = '.';
        if (t != -1) return t;
    }
    return -1;
}

// Complete the countLuck function below.
string countLuck(vector<string> &matrix, int k) {
    int m = 0 ;
    int n = 0;
    for (int i = 0; i < matrix.size(); i++) {
        for(int j = 0 ; j < matrix[0].size(); j++){
            if(matrix[i][j] == 'M') {
                m = i;
                n = j;
            }
        }
    }
    matrix[m][n] = 'X';
    if (k == countWaves(matrix, m, n, 0)) return "Impressed";
    return "Oops!";
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    int t;
    cin >> t;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    for (int t_itr = 0; t_itr < t; t_itr++) {
        string nm_temp;
        getline(cin, nm_temp);

        vector<string> nm = split_string(nm_temp);

        int n = stoi(nm[0]);

        int m = stoi(nm[1]);

        vector<string> matrix(n);

        for (int i = 0; i < n; i++) {
            string matrix_item;
            getline(cin, matrix_item);

            matrix[i] = matrix_item;
        }

        int k;
        cin >> k;
        cin.ignore(numeric_limits<streamsize>::max(), '\n');

        string result = countLuck(matrix, k);

        fout << result << "\n";
    }

    fout.close();

    return 0;
}

vector<string> split_string(string input_string) {
    string::iterator new_end = unique(input_string.begin(), input_string.end(), [] (const char &x, const char &y) {
        return x == y and x == ' ';
    });

    input_string.erase(new_end, input_string.end());

    while (input_string[input_string.length() - 1] == ' ') {
        input_string.pop_back();
    }

    vector<string> splits;
    char delimiter = ' ';

    size_t i = 0;
    size_t pos = input_string.find(delimiter);

    while (pos != string::npos) {
        splits.push_back(input_string.substr(i, pos - i));

        i = pos + 1;
        pos = input_string.find(delimiter, i);
    }

    splits.push_back(input_string.substr(i, min(pos, input_string.length()) - i + 1));

    return splits;
}
