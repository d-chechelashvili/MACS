1)

    b)  დისტანცია წარმოვიდიგნოთ როგორც
        დისტანცია პირველიდან საერთო მშობლამდე + დისტანცია მეორედან საერთო მშობლამდე
        ოკამის სამართებლის პრინციპით ვთქვათ, რომ თანაბრად დაშორდნენ მშობელს სიგრძეებით
        ანუ საერთო მშობლის სიგრძე იქნებოდა სიგრძეების ჯამის ნახევარი
        ყველაზე კარგ შესაძლო ვარიანტში ორივე ემთხვევა საერთო მშობელს(ანუ ერთმანეთსაც)
        ყველაზე ცუდ ვარიანტში უსასრულო აცდენა აქვთ ანუ ქულა მინუს უსასრულობაა.
        ერთმანეთთან დამთხვევის ქულა შევადაროთ საერთო მშობელთან მაქსიმალურ დამთხვევის ქულას
        და ასე განვსაზღვროთ დისტანცია.

        (-∞, max_score] ინტერვალი უნდა გადავაქციოთ [0, +∞) ინტერვალად
        ამისათვის გავამრავლოთ მინუსზე და დავუმატოთ max_score

        მემგონი ნამეტან floatებს ვწერ მარა python2.7 არ ვიცი როგორ მუშაობს და არ გააფუჭებს არაფერს
        max_score = float(float(len(seq1) + len(seq2))/2.0) * 3.0
        distance = float(float(score) * -1.0 + max_score)

    c, d)
        ყველა შესაძლო შედარება გვაძლევს შემდეგ შედეგს:
            Human_A13, Mouse_A13 - Score: 2971, Distance: 506.0
            Human_A13, Mouse_D13 - Score: 975,  Distance: 2305.5
            Human_D13, Mouse_A13 - Score: 968,  Distance: 2270.5
            Human_D13, Mouse_D13 - Score: 2340, Distance: 702.0 
            Human_A13, Human_D13 - Score: 967,  Distance: 2295.5
            Mouse_A13, Mouse_D13 - Score: 954,  Distance: 2302.5

            
        ამ მონაცემებიდან შეგვიძლია ვიმსჯელოთ, რომ 
        გენებს შორის დისტანციისთვის ადამიანობა და თაგვობა ნაკლებადაა განმაპირობებელი ფაქტორი 
        შესაბამისად A13 და D13 გენების გაყოფა გაცილებით ადრე უნდა მომხდარიყო ვიდრე ადამიანისა და თაგვის.
        რადგანაც ადამიანსა და თაგვს შორის ერთიდაიმავე გენების დისტანცია საშუალოდ 604-ია
        604 შევუსაბამოთ დროში 70 მილიონ წელიწადს. 
        და ვთქვათ, რომ ამ გენების გაყოფა დაახლოებით 250-260 მილიონი წლის წინ უნდა მომხდარიყო.


2)
    a) სულ 62829 დამთხვევაა, აქედან 24.7% არის დიაგონალზე. დიაგონალზე დამთხვევები იმიტომაა უფრო "სარწმუნო"
    რადგანაც ერთიდაიგივე უბანში ხვდება და შესაბამისად დიდი ალბათობით ერთიდაიმავე რაღაცებზეა პასუხსიმგებელი.

    b)
        i. kmerlen=100 დავწერე. შეიცვალა ის, რომ გახდა 1198 დამთხვევა. აქედან ყველა დიაგონალზეა. ალბათ იმიტომ რომ
        რაც უფრო გრძელია მიმდევრობა შემთხვევითი დამთხვევა უფრო იშვიათია და მხოლოდ რეალური დამთხვევები ხდება.
        ii. შევცვალე kmerlen = 60 და key = seq[i:i + kmerlen:2]. 23933 დამთხვევა, 38.7% დიაგონალზე.
        iii.შევცვალე kmerlen = 90 და key = seq[i:i + kmerlen:3]. 8887 დამთხვევა, 93.8% დიაგონალზე.
        iv. შევცვალე kmerlen = 120 და key = seq[i:i + kmerlen:4]. 6044 დამთხვევა, 82.1% დიაგონალზე.
        v. პირველი სექვენსის ჰეშების შენახვისას, ან მეორეს მოძებნისას(რომელიც უფრო მოკლეა იმის მიხედვით)
             ყველა შესაძლო მაქსიმუმ 2 mismatch-იან მიმდევრობას განვიხილავდი(შევინახავდი ან მოვძებინდი). kmerlen=100.
    c) iii არის დიაგონალზე განლაგებული ყველაზე მეტად. შედარების ეს მეთოდი პატიობს 1 ან 2 სიგრძის მოდიფიკაციებს
        მაგრამ შედარებით დიდ არეალზე უნდა იყოს შენარჩუნებული მსგავსება.
    d) sensitivity-ს ზრდა იწვევს specificity-ს შემცირებას და პირიქით. ჰეშირების პარამეტრების ზრდა იწვევს დიაგონალზე
        განლაგებული ელემენტების პროცენტულობის ზრდას. მაგრამ რაღაც ეტაპზე,
        როდესაც ზედმეტად დიდი არეა იფარება შესადარებლად ისევ იწყება კლება დიაგონალზე განლაგებული ელემენტების.
    e) kmerlen = 1530 და ყოველი 51-ე base უნდა დაემთხვეს(სხვა პარამეტრებითაც ჩანდა მარა ყველაზე სუფთად ამ პარამეტრებზე ჩანს).
        ასევე, seq1-ის დაჰეშვისას შევცვალე კოდი შემდეგნაირად(ვატრიალებ და კომპლემენტარულებს ვსვამ): 
            key = "".join(map(lambda base: COMPLEMENTS[base], reversed(seq1[i:i + kmerlen:51]))) 
        (სურათი - reverse.jpg)

3)
    a) GC-rich ან არაGC-rich რეგიონების სიგრძის განაწილება იქნება საშუალოდ რამდენჯერაც დარჩება იგივე სთეითში დავარქვათ N.
        ანუ თუ მოხვდა ზოგადადდ სთეითში, რომლის თავის თავში გადასვლის ალბათობა არის akk,
        akk არის მიღებული შემდეგნაირად, რომ N-1ჯერ უნდა დარჩეს საკუთარ თავში და 1ხელ უნდა გადავიდეს სხვა სთეითში. 
        ანუ akk = N-1/N. აქედან N*akk = N-1 => 
        => N*akk - N = -1 => 
        => N - N*akk = 1 => 
        => N(1-akk) = 1 =>
        => N = 1/(1-akk). 
        პასუხი: 1/(1-akk)
    b) accuracy: 83.36%
    c) mystery1: 71.89%, mystery2: 68.66%, mystery3: 67.85%
    d) სიგრძეების მიხედვით რომ შევუცვალოთ პარამეტრები უკეთესი შედეგი უნდა მოგვცეს თეორიულად.
        მაგრამ არ ემორჩილება მაგ წესს მაინცდამაინც, ამიტომ ვერ ვიტყვით ასე პირდაპირ.
